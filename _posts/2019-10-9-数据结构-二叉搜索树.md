---
layout: article
title: 数据结构 二叉搜索树
tags: 数据结构 LeetCode 树 搜索树
mode: immersive
key: post20191009
lightbox: true
cover: https://s2.ax1x.com/2019/10/10/uT4pzF.jpg
header:
  theme: dark
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(40, 129, 161 , .4), rgba(80, 171, 204, .4))'
    src: https://s2.ax1x.com/2019/10/10/uThyxe.png
---

包括二叉搜索树的简介、验证

<!--more-->

<br/>

<span style="background-color:#fc4d50;">文字</span>

<br/>

## 二叉搜索树

　　1. 节点的左子树**只**包含小于当前节点的数
  
　　2. 节点的右子树**只**包含大于当前节点的数
  
　　3. 所有的左子树和右子树自身也是一个二叉搜索树
  
<br/>

<br/>

## 验证二叉搜索树

　　**LeetCode 98**
　　
- 迭代
  
  　　这里C++迭代的时候，相比于Java和python有一个不方便的地方：Java和python在helper函数的参数可以直接用int，其存在null的int；而C++中int没有null值，因此只能用指针。

  ```c++
  class Solution {
  public:
      bool isValidBST(TreeNode* root) {

          return helper(root, nullptr, nullptr);

      }

      bool helper(TreeNode* p, int* lower, int* higher) {

          if(p == nullptr)
              return true;

          int val = p->val;
          if(lower != nullptr && val <= *lower)    return false;
          if(higher != nullptr && val >= *higher)   return false;

          if(!helper(p->left, lower, &val))     return false;
          if(!helper(p->right, &val, higher))   return false;

          return true;
      }
  };
  ```
  
  <br/>
  
- 中序遍历

  　　中序遍历是<u>左-中-右</u>的顺序，对于二叉搜索树来说，遍历到的每一个元素都应该比上一个大、比下一个小。
    
  　　这里我们可以简化一下，只要确保每次新读到的都比上一个大，就可以保证它是二叉搜索树。因此只需要保存前一节点的信息。
   
  　　在具体实现时，有一个需要注意的地方：`INT_MIN = -2147483648`；`INT_LONG = -9223372036854775808`。这里需要用long类型，因为测试样例中有小于INT_MIN的例子。
    
    ```c++
    class Solution {
  public:
      bool isValidBST(TreeNode* root) {

          stack<TreeNode*> s;
          long pre = LONG_MIN;
          TreeNode* p = root;

          while(p || !s.empty()) {

              while(p) {
                  s.push(p);
                  p = p->left;
              }

              p = s.top();
              s.pop();

              // 下面这里就是验证BST的逻辑，如果当前节点小于等于前面读取到的节点，则不是BST
              if(p->val <= pre)   return false;

              pre = p->val;       // 千万不要忘记更新
              p = p->right;
          }
          return true;
      }
  };
    ```
