---
layout: article
title: 数据结构 树的遍历
tags: 数据结构, LeetCode, 树
mode: immersive
lightbox: true
cover: https://s2.ax1x.com/2019/10/06/ugG4Zd.png
header:
  theme: dark
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
    src: http://pxdy964t4.bkt.clouddn.com/%E6%A0%87%E9%A2%98%E5%9B%BE2.png
---



数据结构之树的遍历，Leetcode
<!--more-->


<br/>

<br/>

## 深度优先搜索


<br/>

### 中序遍历


- **递归**

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */
  class Solution {
      
  private:
      vector<int> ans;
      
  public:
      vector<int> inorderTraversal(TreeNode* root) {
          
          if(root) {
              inorderTraversal(root->left);
              ans.push_back(root->val);
              inorderTraversal(root->right);
          }
          
          return ans;
      }
  };
  ```

  
- **迭代**

  ```c++
  class Solution {
      
  public:
      vector<int> inorderTraversal(TreeNode* root) {
          
          vector<int> ans;
          stack<TreeNode> s;
          TreeNode* t = root;
          
          while(t != nullptr || s.empty() == false) {
              
              while(t != nullptr) {
                  s.push(*t);
                  t = t->left;
              }
              
              if(s.empty() == false) {
                  ans.push_back(s.top().val);
                  t = s.top().right;
                  s.pop();
              }
          }
          
          return ans;
      }
  };
  ```
  
<br/>

### 前序遍历

- **递归**
  ```c++
  class Solution {
  
    private:
      vector<int> ans;
      
    public:
      vector<int> preorderTraversal(TreeNode* root) {
          if(root) {
              ans.push_back(root->val);
              preorderTraversal(root->left);
              preorderTraversal(root->right);
          }
          return ans;
      }
    };
  ```

- **迭代**
  ```c++
  class Solution { 
  
  private:
      vector<int> ans;
      stack<TreeNode*> s;
      
  public:
      vector<int> preorderTraversal(TreeNode* root) {

          TreeNode* p = root;
          
          while(p || !s.empty()) {
          
              while(p) {
                  ans.push_back(p->val);
                  s.push(p);
                  p = p->left;
              }
              
              p = s.top();
              s.pop();
              p = p->right;
          }

          return ans;
      }
  };
  ```
  
  
<br/>

### 后序遍历

- **递归**
  ```c++
  class Solution {
  private:
      vector<int> ans;

  public:
      vector<int> postorderTraversal(TreeNode* root) {
          if(root) {
              postorderTraversal(root->left);
              postorderTraversal(root->right);
              ans.push_back(root->val);
          }
          return ans;
      }
  };
  ```
  
- **迭代**
  
  - 方法一
      在前序遍历的基础上改：前序遍历 —— 根-左-右，后序遍历 —— 左-右-根
      Step1: 将前序中“当前节点插入vector最后”，改为“当前节点插入vector最前”。这样变成了 右-左-根（完全逆序）。
      Step2: 将左和右的顺序调换
      得到如下算法：
    ```c++
    class Solution {
    private:
        vector<int> ans;
        stack<TreeNode*> s;

    public:
        vector<int> postorderTraversal(TreeNode* root) {

            TreeNode* p = root;

            while(p || !s.empty()) {

                while(p) {
                    ans.insert(ans.begin(),p->val);
                    s.push(p);
                    p = p->right;
                }

                p = s.top();
                s.pop();
                p = p->left;
            }

            return ans;
        }
    };
    ```
  - 方法二
      其实和上一种总体来讲是相同的，都是逆序输出，不过具体实现有所不同。
      这里是利用压栈，先压左再压右，然后弹栈一次，来实现上一方法中Step2的效果。
      换言之，后序遍历的读取顺序是 —— 从下到上，从左到右；逆序的话就是 —— 从上到下，从右到左。（注意，不能说 广搜 + 逆序输出 = 后序遍历）
    ```c++
    class Solution {
    private:
        vector<int> ans;
        stack<TreeNode*> s;

    public:
        vector<int> postorderTraversal(TreeNode* root) {

           if(root == nullptr)
               return ans;

            s.push(root);
            TreeNode* p;

            while(!s.empty()) {

                p = s.top();
                s.pop();
                ans.insert(ans.begin(), p->val);

                if(p->left != nullptr)
                    s.push(p->left);
                if(p->right != nullptr) 
                    s.push(p->right);
            }

            return ans;
        }
    };
    ```
    
  - 方法三
      传统方法
    ```c++
    class Solution {
    private:
        vector<int> ans;
        stack<TreeNode*> s;

    public:
        vector<int> postorderTraversal(TreeNode* root) {

            TreeNode* p = root;
            TreeNode* pre = nullptr;

            while(p || !s.empty()) {

                while(p) {
                    s.push(p);
                    p = p->left;
                }
                p = s.top();

                // 注意两个指针置为nullptr的时机
                if(!p->right || pre == p->right) {    // 如果已经读取过右子树
                    s.pop();
                    ans.push_back(p->val);
                    pre = p;
                    p = nullptr;
                } else {                                        // 如果没有读过右子树
                    p = p->right;
                    pre = nullptr;
                }

            }


            return ans;
        }
    };
    ```
  
<br/>

<br/>

### 广度优先搜索


